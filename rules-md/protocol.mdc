## PHASE A: Strategic Foresight & Goal Decomposition
1.  **Goal Definition:** Clearly outline the objective of the request or project, defining target deliverables and supporting artifacts. This may involve multiple inter-agent task chains. *Consider creating a new entity in Memory for the overall project or goal.*
2.  **Decomposition & Sequence Anticipation:** Break down the goal into the smallest logical, independently verifiable subtasks. For each subtask, anticipate likely agent operations, the artifacts they will generate, and potential next agents or decision points. Consider dependencies and opportunities for parallelization. *Create entities in Memory for subtasks and define 'dependsOn' or 'relatedTo' relations.*
3.  **Alternative Analysis (Mandatory for non-trivial tasks):** Explore at least two distinct approaches or agent chains, evaluating them based on potential output velocity, artifact richness, and robustness. Document alternatives and the rationale for selection. *Record alternative plans and their evaluations as observations or related entities in Memory.* Consider potential failure modes and mitigation strategies.
4.  **Assumption Identification & Challenge:** Document all key assumptions for the overall goal and initial subtasks. Plan verification subtasks or procedures to confirm these assumptions. *Store identified assumptions and verification plans in Memory.*
5.  **Memory Recall & Initial Contextualization:** Actively query the Knowledge Graph (Memory) using `mcp_memory_search_nodes`, `mcp_memory_open_nodes`, or `mcp_memory_read_graph` to retrieve existing information relevant to the goal, project, or involved entities. This step is crucial for avoiding redundant work and building upon existing knowledge. *Synthesize retrieved memory and log key insights as observations on the main project/goal entity.*

## PHASE B: Operational Orchestration & Task Delegation (MCP)
1.  **Delegation & Initiation:** Assign initial subtasks via MCP (`mcp_project-manager_create_task`) with clarity and efficiency. *Link the created MCP task ID to the corresponding subtask entity in Memory.* Use `mcp_memory_add_observations` or `mcp_memory_create_relations`.
    *   **Task Context (Mandatory):** Provide comprehensive context, clear input/output parameters, references to prior tasks/goals/artifacts, explicit assumptions, and detailed specifications for expected output artifacts. If anticipated in Phase A, note potential logical next agents and the artifacts they are expected to consume/produce. *Ensure key context, inputs, and expected outputs are also captured as observations or related entities in Memory.* Utilize `mcp_memory_create_entities`, `mcp_memory_add_observations`, or `mcp_memory_create_relations`.
    *   **Initial Status (Mandatory):** Set an appropriate initial status (e.g., "To Do", "Pending Activation"). *Log the initial status in Memory.* Use `mcp_memory_add_observations`.
2.  **Task ID Logging & Chain Tracking:** Record all created task IDs within the `ProjectManager` task. Maintain an understanding of task chains, dependencies, artifact flow, and anticipated decision points. Create a visual map or structured log if complex. *Synchronize task chain structure and dependencies with Memory using `mcp_memory_create_relations`.* Log artifact flow details as observations.

## PHASE C: Multi-Vector Validation & Triangulation (Post-Operation)
0.  **Status Monitoring (Continuous):** Periodically monitor subtask status and artifact delivery (`mcp_project-manager_get_tasks` / `mcp_project-manager_get_task_by_id`). Pay attention to statuses indicating handoffs or awaiting ProjectManager review to track automated chains and identify points for strategic direction. *Regularly update the status of task entities in Memory based on MCP task status using `mcp_memory_add_observations` or `mcp_memory_update_relations` if status is modeled as a relation.* Query Memory to understand the overall project state.
1.  **Data & Artifact Retrieval & Scrutiny:** Obtain full details and all associated artifacts (`mcp_project-manager_get_task_by_id`). Analyze the report, all output artifacts (code, data, logs), verification data, and the agent's workflow continuation decision. *Store key artifacts or references to them (e.g., file paths, links) as observations on the relevant task or artifact entities in Memory using `mcp_memory_add_observations`.* Use `mcp_memory_open_nodes` to retrieve prior context from Memory.
2.  **Multi-Method Verification (Mandatory):** For non-trivial tasks, employ at least two MCP tools. For critical tasks and code artifacts, employ at least three MCP tools (may be delegated to an appropriate analysis agent, who will produce their own verification artifacts). Utilize diverse tools. Verify not only the completed task and its primary artifacts but also the appropriateness and correctness of any follow-up tasks created (or the decision not to create one) against the strategic plan, anticipated artifact sequences from Phase A, and the mandates in the core agent execution loop ([loop.mdc](mdc:.cursor/rules/loop.mdc)). Log verification outcomes, including updating relevant entities or observations in Memory using `mcp_memory_add_observations` or `mcp_memory_update_relations`. Retrieve relevant verification protocols or criteria from Memory using `mcp_memory_search_nodes` and `mcp_memory_open_nodes`.
3.  **External Cross-Checking (Mandatory, if applicable):** Cross-check agent-provided information against external sources (e.g., library documentation, web search, prior tasks). Log any discrepancies or new findings as observations in Memory associated with relevant entities using `mcp_memory_add_observations`. *Use `mcp_memory_search_nodes` and `mcp_memory_open_nodes` to retrieve related entities for cross-referencing.*
4.  **Results Analysis & Artifact Chain Validation:** Compare all verification outcomes. Discrepancies, uncertainties, and failures **MUST** be documented. *Log analysis results and identified discrepancies as observations or related entities in Memory.* Use `mcp_memory_create_relations` to link findings to specific tasks or artifacts. Retrieve and analyze task chains from Memory using `mcp_memory_open_nodes`.
    *   If an agent created follow-up tasks: Validate that these are logical, aligned with system mandates and [loop.mdc](mdc:.cursor/rules/loop.mdc), and contribute effectively to the overall goal. *Update Memory to reflect the validation of follow-up tasks.* Use `mcp_memory_add_observations`.
    *   If a task is "Completed" and awaiting ProjectManager: Assess if the agent *should have* created a follow-up task per [loop.mdc](mdc:.cursor/rules/loop.mdc). If so, `ProjectManager` **MUST** initiate the missed follow-up task. Otherwise, determine and initiate the next strategic task. *Query Memory to inform this decision based on the project plan and current state.* Use `mcp_memory_search_nodes` and `mcp_memory_open_nodes`.
    *   If a chain is going astray or an agent made an inappropriate continuation decision, `ProjectManager` **MUST** intervene (see Phase E). *Log the decision and intervention in Memory.* Use `mcp_memory_add_observations`.

## PHASE D: Systemic Integrity Audit & Vulnerability Assessment (Continuous)
1.  **Logic Review:** Scrutinize all reasoning, assumptions, and conclusions within individual tasks and across task chains. *Use Memory to trace the flow of logic and data across related entities and tasks.* Use `mcp_memory_search_nodes` and `mcp_memory_open_nodes`.
2.  **Uncertainty Identification:** Note all ambiguities and areas of low confidence. Propose methods to reduce uncertainty. *Log uncertainties and proposed resolution methods in Memory.* Use `mcp_memory_add_observations`.
3.  **Systematic Weakness Detection (Mandatory):** Actively search for weaknesses, gaps, unchallenged assumptions, and edge cases in the overall workflow and individual agent performance, especially those that could compromise code quality or artifact integrity. Document all findings. *Create entities for identified weaknesses or vulnerabilities and link them to relevant project/task entities in Memory using `mcp_memory_create_entities` and `mcp_memory_create_relations`. Add details as observations.* Use `mcp_memory_search_nodes` to look for patterns of failure.
4.  **Pitfall Documentation:** Record all identified risks (e.g., infinite loops, misdirected task creation, artifact corruption vectors) and the rationale for mitigation or acceptance. *Document risks and mitigation strategies in Memory, linking them to the relevant context.* Use `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`.

## PHASE E: Anomaly Resolution & Corrective Action Protocol
1.  **Deep Context & Artifact Acquisition:** Utilize multiple, diverse methods to gather comprehensive context and all relevant artifacts (logs, failed outputs, configurations) regarding the failure or anomaly. Actively query Memory for historical data or related entities that might provide diagnostic insights using `mcp_memory_search_nodes`, `mcp_memory_open_nodes`, or `mcp_memory_read_graph`. *Log diagnostic steps and findings in Memory.* Use `mcp_memory_add_observations`.
    *   Examples of MCP tools: `mcp_project-manager_get_task_by_id` (for the failed task and related tasks), `mcp_desktop-commander_read_file`, `mcp_desktop-commander_list_directory`, `mcp_desktop-commander_get_file_info`, `mcp_desktop-commander_search_code`, `mcp_web-fetch_fetch`, `default_api.web_search`, `mcp_memory_read_graph`, `mcp_memory_search_nodes`, `mcp_memory_open_nodes`.
2.  **Stated Cause Challenge (Mandatory):** Investigate alternative root causes for task failures or workflow issues, including flawed agent continuation logic or failure to adhere to the handoff protocol in [loop.mdc](mdc:.cursor/rules/loop.mdc). *Record investigated causes and their evaluation in Memory.* Use `mcp_memory_add_observations` or `mcp_memory_create_relations`.
3.  **Recovery Planning / Workflow Correction:** Plan recovery tasks (utilizing Phase A alternatives, corrective actions, or further research), with the primary goal of restoring correct code/artifact production. This may involve creating tasks to correct a previous agent's work, overriding an agent's erroneous follow-up task, creating a missed follow-up task, redirecting a task chain, or halting a specific line of automated task creation. Document the diagnosis and correction plan, including updating Memory with information about the anomaly and resolution using `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`, or `mcp_memory_update_relations`. *Query Memory for similar past anomalies or resolutions.* Use `mcp_memory_search_nodes`.
4.  **Failure Declaration (Last Resort):** Declare failure of a sub-goal or the entire project only if comprehensive analysis confirms the objective is infeasible or unrecoverable. *Log the failure declaration and its justification in Memory.* Use `mcp_memory_add_observations`.

## PHASE F: Terminal Assessment & Retrospective Validation (Project Completion)
1.  **Pause Execution & Artifact Inventory:** Pause all operations and new task creation. Conduct a full inventory and audit of all generated code and artifacts against the initial plan. *Query Memory to retrieve records of all tasks, artifacts, and related findings.* Use `mcp_memory_search_nodes`, `mcp_memory_open_nodes`, or `mcp_memory_read_graph`.
2.  **Comprehensive Reconsideration:** Review the entire process from Phase A, including all automated task chains and their resultant artifacts. Re-evaluate all decisions, assumptions, and verification steps. *Utilize the historical record in Memory to trace decisions and outcomes.* Use `mcp_memory_open_nodes` to traverse the graph.
3.  **Final Weakness Scan:** Conduct a final systematic search for any overlooked issues or weaknesses in the completed work and artifacts. *Compare the final state captured in Memory against the initial plan and success criteria.* Use `mcp_memory_search_nodes` and `mcp_memory_open_nodes`.
4.  **Review Documentation & Generate Final Report:** Document this reconsideration process, noting any concluding thoughts or concerns about the automated workflows and artifact quality. Ensure this documentation is a clear, actionable, and comprehensive final project report. *Synthesize the project history and findings stored in Memory to generate the final report.* Use `mcp_memory_read_graph` or targeted queries.
5.  **Conclude Operations:** Only after completion of the above steps, allow final completion of the request. Confirm that the outcome and the suite of delivered artifacts are satisfactory. *Mark the project entity in Memory as completed and log the final outcome.* Use `mcp_memory_add_observations` or `mcp_memory_update_relations`.

## Agent-Specific Protocols and Enhancements

These enhance the core protocol application.

1.  **Error Escalation and Recovery:**
    *   If a failure, ambiguity, or non-authoritativeness is detected, create an MCP escalation or diagnostic task, referencing the failed/blocked context and logging the reason. Propose a recovery or diagnostic plan, prioritizing swift restoration of production. *Log the escalation and recovery plan in Memory, linking it to the failed task entity.* Use `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`.
2.  **Proactive Anomaly Detection & Opportunity Exploitation:**
    *   After each major step, self-assess for anomalies or unexpected results. Log anomalies in MCP. If an anomaly or successful execution reveals an opportunity to generate additional valuable artifacts (code, tests, documentation), proactively create new sub-tasks. *Log detected anomalies and identified opportunities in Memory, linking them to the relevant context.* Use `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`.
3.  **Redundant, Cross-Rule Verification & Artifact Validation:**
    *   For critical or high-impact changes and all significant code artifacts, create a verification sub-task for a peer rule or agent to independently validate the change and its associated artifacts. *Record the verification plan and outcomes in Memory.* Use `mcp_memory_add_observations`.
4.  **Rule File and Protocol Version Logging:**
    *   Log the version/hash or last-modified timestamp of every rule file and protocol referenced in MCP updates and reports. *Consider storing key rule versions in Memory and linking them to project entities.* Use `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`.
5.  **Automated Rule Recall and Self-Update Check:**
    *   At the start of each process, check for updates to this rule file and core protocols. If a change is detected, log this in MCP and re-fetch/re-parse the rules before proceeding. *Log rule updates in Memory.* Use `mcp_memory_add_observations`.
6.  **Explicit, Auditable Tool Usage Logging:**
    *   Log every tool call (with parameters, results, and identifiers of artifacts consumed/produced) in a structured, machine-readable format in the MCP task description or as an attached artifact. *Optionally, log key tool interactions and their results as observations in Memory.* Use `mcp_memory_add_observations`.
7.  **End-of-Process Self-Reflection & Improvement Proposals:**
    *   At the end of each process, include a brief, itemized self-reflection in your MCP update: what went as planned, what deviated, what could be improved, and any uncertainties or risks detected. *Summarize key reflections and improvement proposals in Memory, potentially creating new entities for proposed improvements.* Use `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`.

## References
*   [system.mdc](mdc:.cursor/rules/system.mdc)
*   [loop.mdc](mdc:.cursor/rules/loop.mdc)
*   [concepts.mdc](mdc:.cursor/rules/concepts.mdc)
*   [roles.mdc](mdc:.cursor/rules/roles.mdc)
*   [init.mdc](mdc:.cursor/rules/init.mdc)
*   [entrypoint.mdc](mdc:.cursor/rules/entrypoint.mdc)
*   This document ([protocol.mdc](mdc:.cursor/rules/protocol.mdc))
*   **Memory (Knowledge Graph) Tools:** `mcp_memory_read_graph`, `mcp_memory_search_nodes`, `mcp_memory_open_nodes`, `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`, `mcp_memory_delete_entities`, `mcp_memory_delete_observations`, `mcp_memory_delete_relations`, `mcp_memory_update_relations`.
