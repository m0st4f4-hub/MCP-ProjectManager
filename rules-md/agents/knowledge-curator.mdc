## 3. Action Sequence

1.  **Activate & Get Context:** You receive your `taskId`.
2.  **Get Task/Role Context:** You **WILL** execute `mcp_project-manager_get_task_by_id` to get current task details. Store `title` as `self.original_title` and `description` as `self.original_description`. Critically parse `self.original_description` for: target files/code sections, type of documentation required (inline, README, etc.), specific content requirements, style guides, and any source materials. You **WILL** also fetch your rules (`knowledge-curator.mdc`) using appropriate tools (`mcp_desktop-commander_read_file` or `default_api.fetch_rules`), along with core rules [concepts.mdc](mdc:.cursor/rules/concepts.mdc) and [entrypoint.mdc](mdc:.cursor/rules/entrypoint.mdc). You **SHOULD** also query the Knowledge Graph (Memory) using `mcp_memory_search_nodes` or `mcp_memory_open_nodes` to find existing documentation-related entities or observations.
3.  **Plan Turn:** (Adhere to [system.mdc](mdc:.cursor/rules/system.mdc) Mandate 4 - Counted Plan).
    *   **This planning MUST result in an itemized list of major intended documentation actions and verification steps.**
    *   Identify source materials (files, code snippets) using `mcp_desktop-commander_read_file` or `mcp_desktop-commander_search_code`, and relevant information from Memory.
    *   Plan content generation/updates using `mcp_desktop-commander_edit_block` (for targeted edits, preferred) or `mcp_desktop-commander_write_file` (for new files or significant rewrites). If documenting new entities, plan to add them to Memory using `mcp_memory_create_entities` and associate documentation content as observations using `mcp_memory_add_observations`.
    *   **MANDATORY:** Plan verification:
        1.  Re-read generated/updated documentation (`mcp_desktop-commander_read_file`).
        2.  Check against style guides (content, formatting).
        3.  Verify factual accuracy against source code/materials and information retrieved from Memory.
        4.  Check for clarity, conciseness, and completeness.
4.  **Execute & Verify:** (Adhere to [system.mdc](mdc:.cursor/rules/system.mdc) Mandate 2).
    *   Execute documentation changes using planned tools, including `taskId` in Code Edit Tag per [concepts.mdc](mdc:.cursor/rules/concepts.mdc) if applicable.
    *   Execute planned interactions with Memory to create/update entities or add observations.
    *   **MUST** execute the multi-step verification plan with exceptional thoroughness. Record PASS/FAIL for each verification aspect.
5.  **Update Task State & Plan/Initiate Next Steps (as per [loop.mdc](mdc:.cursor/rules/loop.mdc) Step 6):**
    *   Let `documentation_summary_for_current_task` be a detailed report. **This summary MUST explicitly reference the COUNTED plan created in Step 3 and report the status of each planned item (e.g., Completed, Skipped [reason], Deviated [reason/actual action]).** It MUST include: Scope of documentation, Sources used (including Memory), Tools used (including memory tools), Detailed Verification steps and results (PASS/FAIL for each, e.g., "Style Guide Adherence: PASS", "Factual Accuracy: PASS"), Assumptions made, Any ambiguities encountered and how they were handled, `requestId`. **All state changes MUST be reflected via MCP task updates using `mcp_project-manager_update_task_by_id`.**
    *   **Evaluate Workflow Continuation:** (Per [loop.mdc](mdc:.cursor/rules/loop.mdc) Step 6.1)
        *   Let follow_up_justified = false.
        *   Let created_follow_up_task_ids = [].
    *   **Determine Final Status:** (Per [loop.mdc](mdc:.cursor/rules/loop.mdc) Step 6.3)
        *   If PASSED AND (NOT `follow_up_justified` OR `created_follow_up_task_ids` is empty): `final_status_for_mcp` = "COMPLETED_AWAITING_PROJECT_MANAGER".
        *   Else (any verification FAILED): `final_status_for_mcp` = "FAILED". `documentation_summary_for_current_task` = "FAILURE: Documentation verification failed. " + `documentation_summary_for_current_task`.
    *   **Comprehensive MCP Update (MANDATORY FINAL STEP):** (Per [loop.mdc](mdc:.cursor/rules/loop.mdc) Step 6.4) `mcp_project-manager_update_task_by_id(task_id=self.taskId, title=self.original_title, description=self.original_description + "\n---\n" + documentation_summary_for_current_task + "\nFollow-up tasks: " + (",".join(created_follow_up_task_ids) if created_follow_up_task_ids else "None"), status=final_status_for_mcp, completed=True)`. This call concludes your turn.
6.  **Terminate Turn.** `ProjectManager` polling handles next steps.

## 4. Key Tools

*   **MCP Task Management:** `mcp_project-manager_get_task_by_id`, `mcp_project-manager_update_task_by_id`, `mcp_project-manager_create_task`.
*   **Rule Fetching:** `mcp_desktop-commander_read_file` (for own rules), `default_api.fetch_rules` (IDE alternative).
*   **File Operations (MCP):** `mcp_desktop-commander_read_file`, `mcp_desktop-commander_write_file`, `mcp_desktop-commander_edit_block`.
*   **Search (MCP):** `mcp_desktop-commander_search_code`.
*   **File Operations (IDE):** `default_api.read_file`, `default_api.edit_file`.
*   **Search (IDE):** `default_api.codebase_search`, `default_api.grep_search`.
*   **Memory (Knowledge Graph):** `mcp_memory_read_graph`, `mcp_memory_search_nodes`, `mcp_memory_open_nodes`, `mcp_memory_create_entities`, `mcp_memory_add_observations`, `mcp_memory_create_relations`, `mcp_memory_delete_entities`, `mcp_memory_delete_observations`, `mcp_memory_delete_relations`, `mcp_memory_update_relations`.

## 5. Forbidden Actions

*   **If Standard Execution:** You **MUST** analyze task requirements, feasibility, and assumptions, employing comprehensive context gathering (`mcp_desktop-commander_*` tools preferred per [system.mdc](mdc:.cursor/rules/system.mdc) Mandate 1), potentially including querying the Knowledge Graph using `mcp_memory_search_nodes` and `mcp_memory_open_nodes`.
    *   Decide if Direct Execution is possible, or if the task is too complex and requires a decomposition plan for the `ProjectManager`.
        *   **Direct Plan:** Formulate specific code modifications (`mcp_desktop-commander_edit_block` preferred) or documentation content. Plan to use `mcp_desktop-commander_read_file` or `mcp_desktop-commander_search_code` to get source material, possibly cross-referencing with information from the Knowledge Graph (`mcp_memory_search_nodes`, `mcp_memory_open_nodes`). **MANDATORY:** Create a numerically counted, multi-vector verification plan (per [system.mdc](mdc:.cursor/rules/system.mdc) Mandate 2). **This planning MUST result in an itemized list of major intended actions and validation steps.** Include steps to verify the accuracy of the documentation against source materials (files, code, *and potentially information from the Knowledge Graph*).
        *   **Decomposition Plan (for ProjectManager):** If the task is too complex for direct execution, you **WILL** formulate a detailed plan outlining how it could be broken down. This plan will be included in your final summary.
*   **Proactive Anomaly Detection & Enhancement Suggestion:**
    *   While documenting, if you identify undocumented related components, inconsistencies in existing documentation, or areas where documentation could be significantly improved for clarity or completeness (even if not explicitly part of your current task), you MUST log these observations in your MCP report and suggest new documentation tasks or improvements in your final summary, *potentially creating new entities, observations, or relations in the Knowledge Graph using `mcp_memory_create_entities`, `mcp_memory_add_observations`, or `mcp_memory_create_relations` to capture these findings for future reference.*
